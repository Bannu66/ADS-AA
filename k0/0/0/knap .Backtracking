/* 0/1 Knapsack Problem using Backtracking */

#include <stdio.h>

#define MAX 20

float final_profit;
float final_wt;
int w[MAX], p[MAX];
int n, m;
int temp[MAX], x[MAX];

float Bound_calculation(int cp, int cw, int k);
void Backtracking(int k, int cp, int cw);

void main()
{
    int i;
    printf("\n----");
    printf("\nKnapsack problem using Backtracking");
    printf("\n----");

    printf("\nEnter number of objects you want: ");
    scanf("%d", &n);

    printf("\n----\n");
    for (i = 1; i <= n; i++) {
        printf("\nEnter weight and value for object %d: ", i);
        scanf("%d %d", &w[i], &p[i]);
    }

    printf("\nEnter capacity of knapsack: ");
    scanf("%d", &m);

    printf("\n----");
    printf("\nWeight  Profit\n");
    for (i = 1; i <= n; i++) {
        printf("\n%d  %d", w[i], p[i]);
    }

    Backtracking(0, 0, 0);

    printf("\n----");
    printf("\nFollowing objects are included:");
    printf("\n----\n");

    for (i = 1; i <= n; i++) {
        if (x[i] == 1)
            printf("\n%d", i);
    }

    printf("\n----");
    printf("\nFinal weight: %.2f", final_wt);
    printf("\nFinal profit: %.2f", final_profit);
}

/* Backtracking function */
void Backtracking(int k, int cp, int cw)
{
    int new_k, new_cp, new_cw, j;

    if (cw + w[k] <= m) {
        temp[k] = 1;
        if (k < n) {
            new_k = k + 1;
            new_cp = cp + p[k];
            new_cw = cw + w[k];
            Backtracking(new_k, new_cp, new_cw);
        } else {
            final_profit = cp;
            final_wt = cw;
            for (j = 1; j <= n; j++)
                x[j] = temp[j];
        }
    }

    if (Bound_calculation(cp, cw, k) > final_profit) {
        temp[k] = 0;
        if (k < n)
            Backtracking(k + 1, cp, cw);
    }
}

/* Function to calculate upper bound */
float Bound_calculation(int cp, int cw, int k)
{
    int i;
    float ub = cp;
    float c = cw;

    for (i = k + 1; i <= n; i++) {
        c = c + w[i];
        if (c <= m)
            ub = ub + p[i];
        else {
            ub = ub + (1.0 * (m - (c - w[i])) / w[i]) * p[i];
            return ub;
        }
    }
    return ub;
}

o/p:
knapsack problem using BackTracking
----------------------------------
enter no of objs you want:3
-----------------------------
enter weight andd valuefor object:1:12
enter weight and 		2:12
				3:18
15
enter capacity of knapsack:20
-----------------------------
weight profit
------------------------------
12 1
2 13
18 5
included:
1
2
final weight :14.00
final profit:14.00
